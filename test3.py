from udacidrone import Drone
from udacidrone.connection import MavlinkConnection
from udacidrone.messaging import MsgID


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from bresenham import bresenham
import utm
from enum import Enum
from queue import PriorityQueue
from skimage.morphology import medial_axis
from skimage.util import invert
from scipy.spatial import Voronoi, voronoi_plot_2d
from shapely.geometry import Polygon, Point
#from shapely import STRtree
from sklearn.neighbors import KDTree
import networkx as nx
import time


def read_obstacle_data(filename):
    """
    This function returns a nx6 numpy array containing obstacle geometry. Each row of the data numpy
            array contains columns with this information: PosX, PosY, PosZ, HalfX, HalfY, HalfZ.
    The function takes as input the string file name for an obstacle CSV file. 
    """
    data = np.loadtxt(filename, delimiter=',', skiprows=2)
    
    return data
    
def create_configuration(data, drone_altitude=10, safety=1):
    """
    Inputs: 
        data: n x 6 numpy array, contains obstacle geometry. Each row of the data numpy
            array contains columns with this information: PosX, PosY, PosZ, HalfX, HalfY, HalfZ.
        drone_altitude: drone altitude, meters above ground
        safety_distance: safety distance, meters of padding around obstacles. 
    Returns: 
        grid: n x m numpy boolean array, representing a grid-based map, where each cell
            is either tagged obstacle (1 = True) or free space (0 = False). Each grid cell is
            equivalent to a 1m x 1m square in space.
        edges: a list of lists of 2-tuples, each providing the start and end coordinates
            of the on-grid vertices not intersecting obstacles generated by 
            a Voronoi algorithm.
    """
    # First, measure the dimensions of the obstacle data.
    r = [0,0,0,0,0,0]
    r[0] = int(np.floor(np.amin(data[:,0] - data[:,3]))) - safety #North min
    r[1] = int(np.ceil(np.amax(data[:,0] + data[:,3]))) + safety #North max
    r[2] = int(np.floor(np.amin(data[:,1] - data[:,4]))) - safety #East min
    r[3] = int(np.ceil(np.amax(data[:,1] + data[:,4]))) + safety #East max
    r[4] = int(np.floor(np.amin(data[:,2] - data[:,5]))) - safety #Alt min
    r[5] = int(np.ceil(np.amax(data[:,2] + data[:,5]))) + safety #Alt max
    offset = [0,0,0]
    offset[0] = int(np.amin(data[:,0])) #North offset
    offset[1] = int(np.amin(data[:,1])) #East offset
    offset[2] = int(np.amin(data[:,2])) #Down offset
    
    # Calculate the size of the configuration space next.
    s = [0,0,0]
    s[0] = r[1] - r[0] 
    s[1] = r[3] - r[2]
    s[2] = r[5] - r[4]
    
    # After that, initialize the configuration space.
    configuration = np.zeros((s[0], s[1]), dtype=float)
    configuration_25d = np.zeros((s[0], s[1]), dtype=float)
    
    # Populate the configuration space with obstacles. Also, obstacle locations will serve as both Voronoi points and Shapely polygon vertices.
    points = []
    obstacle = [0,0,0,0]
    
    for i in range(data.shape[0]):
        north, east, down, d_north, d_east, d_down = data[i,:]          
            
        if drone_altitude < down + d_down:
            obstacle = [
                int(north - offset[0] - d_north - safety),
                int(north - offset[0] + d_north + safety),
                int(east - offset[1] - d_east - safety),
                int(east - offset[1] + d_east + safety)
            ]
            height = down + d_down
            configuration[obstacle[0]:obstacle[1]+1, obstacle[2]:obstacle[3]+1] = 1
            configuration_25d[obstacle[0]:obstacle[1]+1, obstacle[2]:obstacle[3]+1] = height - offset[2]
            points.append((int(north - offset[0]), int(east - offset[1])))

    
    voronoi = Voronoi(points)

    # From the Voronoi graph, extract edges that are safe to fly.
    edges = []
    for v in voronoi.ridge_vertices:
        p1 = voronoi.vertices[v[0]] # Look up index of one end of the edge
        p2 = voronoi.vertices[v[1]] # and then the other. Then get coordinates.
        x1 = int(p1[0])
        y1 = int(p1[1])
        x2 = int(p2[0])
        y2 = int(p2[1])
        trace = bresenham(x1,y1,x2,y2)
        hit = False
        for p in trace:
            if p[0] < 0 or p[0] >= s[0] or p[1] < 0 or p[1] >= s[1]:
                hit = True
            if not hit:
                if configuration[p[0], p[1]] == 1:
                    hit = True
        if not hit:
            edges.append( ((x1, y1),(x2, y2)) )

    return configuration, configuration_25d, edges, s

def extract_polygons(data, safety=1):
    # First, measure the dimensions of the obstacle data.
    r = [0,0,0,0,0,0]
    r[0] = int(np.floor(np.amin(data[:,0] - data[:,3]))) - safety #North min
    r[1] = int(np.ceil(np.amax(data[:,0] + data[:,3]))) + safety #North max
    r[2] = int(np.floor(np.amin(data[:,1] - data[:,4]))) - safety #East min
    r[3] = int(np.ceil(np.amax(data[:,1] + data[:,4]))) + safety #East max
    r[4] = int(np.floor(np.amin(data[:,2] - data[:,5]))) - safety #Alt min
    r[5] = int(np.ceil(np.amax(data[:,2] + data[:,5]))) + safety #Alt max
    offset = [0,0,0]
    offset[0] = int(np.amin(data[:,0])) #North offset
    offset[1] = int(np.amin(data[:,1])) #East offset
    offset[2] = int(np.amin(data[:,2])) #Alt offset
    
    # Calculate the size of the total obstacle space next.
    s = [0,0,0]
    s[0] = r[1] - r[0] 
    s[1] = r[3] - r[2]
    s[2] = r[5] - r[4]
    
    polygons = []
    for i in range(data.shape[0]):
        north, east, down, d_north, d_east, d_down = data[i,:]
        obstacle = [
                int(north - offset[0] - d_north - safety),
                int(north - offset[0] + d_north + safety),
                int(east - offset[1] - d_east - safety),
                int(east - offset[1] + d_east + safety),
                int(down - offset[2] - d_down - safety),
                int(down + offset[2] + d_down + safety)
        ]
        obstacle_center = [
            int(north - offset[0]),
            int(east - offset[1]),
            int(down - offset[2])
        ]
        p1 = np.array([obstacle[0], obstacle[2]])
        p2 = np.array([obstacle[0], obstacle[3]])
        p3 = np.array([obstacle[1], obstacle[3]])
        p4 = np.array([obstacle[1], obstacle[2]])
        p = np.array([p1, p2, p3, p4])
        
        height = obstacle[5] - obstacle[4]
        polygons.append((Polygon(p), height, obstacle_center))
        
    return polygons

def build_graph_from_edges(edges):
    Graph = nx.Graph()
    for edge in edges:
        distance = np.sqrt((edge[0][0] - edge[1][0])**2 + (edge[0][1] - edge[1][1])**2)
        Graph.add_edge((edge[0][0], edge[0][1]), (edge[1][0], edge[1][1]), weight=distance)
        
    return Graph

def generate_samples(n, data, safety=2):
    """
    Generate a n x 3 numpy array of (N, E, D) coordinate points randomly, uniformly
    distributed through the 3D map data. Pads obstacles with s meters of safety distance.
    """
    # Measure the dimensions of the 3d map first. 
    r = [0,0,0,0,0,0]
    r[0] = int(np.floor(np.amin(data[:,0] - data[:,3]))) - safety #North min
    r[1] = int(np.ceil(np.amax(data[:,0] + data[:,3]))) + safety #North max
    r[2] = int(np.floor(np.amin(data[:,1] - data[:,4]))) - safety #East min
    r[3] = int(np.ceil(np.amax(data[:,1] + data[:,4]))) + safety #East max
    r[4] = int(np.floor(np.amin(data[:,2] - data[:,5]))) - safety #Alt min
    r[5] = int(np.ceil(np.amax(data[:,2] + data[:,5]))) + safety #Alt max

    # Calculate the size of the configuration space next.
    s = [0,0,0]
    s[0] = r[1] - r[0] 
    s[1] = r[3] - r[2]
    s[2] = r[5] - r[4]

    # After that, generate random sample points. 
    x = np.random.uniform(0,s[0],n) 
    y = np.random.uniform(0,s[1],n) 
    z = np.random.uniform(10,10,n) 
    samples = np.array(list(zip(x,y,z)))
    sample_tree = KDTree(samples)
    return samples, sample_tree

data = read_obstacle_data('colliders.csv')
drone_altitude = 10
safe_distance = 0
grid, map_25d, edges, s = create_configuration(data, drone_altitude, safe_distance)
Graph = build_graph_from_edges(edges)
polygons = extract_polygons(data, safe_distance)
samples, sample_tree = generate_samples(1000, data)
print(data)

"""
This code block will contain an A* search algorithm that 
works on graph data structures. 
"""
def h(n1, n2):
    """
    Computes and returns the straight line distance between two 2-tuple nodes given their (north, east) coordinates.
    """
    return np.sqrt((n1[0]-n2[0])**2+(n1[1]-n2[0])**2)

def find_closest_vertex(given_vertex, vertices):
    """
    Given a (North, East) 2-tuple coordinate pair and a list of 2-tuples containing (North, East) pairs, return the pair in the latter closest to the former.
    """
    distance = 1000000
    for vertex in vertices:
        d = np.sqrt((given_vertex[0]-vertex[0])**2 + (given_vertex[1]-vertex[1])**2)
        if d < distance:
            distance = d
            closest_vertex = (vertex[0], vertex[1])
    return closest_vertex
            
def astar_graph(graph, start, goal, h):
    """
    Summary
    This function searches a graph using the A Star search algorithm. 
    
    Inputs
        graph: a graph data structure to search
        start: a (North, East) 2-tuple representing the start location
        goal: a (North, East) 2-tuple representing the goal location
        h: a heuristic function
    Outputs
        path: list of 2-tuples representing the nodes traversed in sequence. 
        cost: the total cost of taking the returned path
    """
    
    # Initialize important containing variables first. Leverage the Priority Queue data structure.
    q = PriorityQueue()
    path = []
    path_cost = 0
    q.put((0, start))
    visited = set(start)
    branch = {}
    found = False
    
    # Next, consider nodes adjacent to the node in question, starting from the start node. Compute the cost of traveling to each and prioritize nodes
    # based on that amount. 
    while not q.empty():
        item = q.get()
        current_node = item[1]
        if current_node == start:
            current_cost = 0.0
        else:              
            current_cost = branch[current_node][0]
        if current_node == goal:        
            print('Found a path.')
            found = True
            break
        else:
            for key in graph.adj[current_node]:
                next_node = key
                branch_cost = current_cost + Graph.adj[current_node][next_node]['weight']
                queue_cost = branch_cost + h(next_node, goal)
                
                if next_node not in visited:
                    visited.add(next_node)
                    branch[next_node] = (branch_cost, current_node)
                    q.put((queue_cost, next_node))
   
    # Last, build a list of to represent the path traversed from start to goal when one is found.
    if found:
        n = goal
        path_cost = branch[n][0]
        path.append(goal)
        while branch[n][1] != start:
            path.append(branch[n][1])
            n = branch[n][1]
        path.append(start)
    else:
        print('************')
        print('Failed to find a path.')
        print('************')
        
    return path[::-1], path_cost

start = (400,300)
goal = (50,800)
path, cost = astar_graph(Graph,  find_closest_vertex(start, Graph.nodes), find_closest_vertex(goal, Graph.nodes), h)
#(400, 300), (400, 558)
#print(path)
#print(cost)

plt.imshow(grid, cmap='Greys', origin="lower")
plt.rcParams["figure.figsize"] = [8, 8]

# Plot the results of the A Star graph search. 
plt.imshow(grid, cmap='Greys', origin='lower')

for edge in edges:
    p1 = edge[0]
    p2 = edge[1]
    plt.plot([p1[1], p2[1]], [p1[0], p2[0]], 'b-')
        
for i in range(len(path)-1):
    p1 = path[i]
    p2 = path[i+1]
    plt.plot([p1[1], p2[1]], [p1[0], p2[0]], 'r-')

plt.plot([start[1], path[0][1]],[start[0], path[0][0]],'g-')
plt.plot([goal[1], path[-1][1]],[goal[0], path[-1][0]],'g-')

plt.xlabel('Eastings (m)')
plt.ylabel('Northings (m)')
plt.title('The Flight Plan')
plt.show()
print(Graph)


conn = MavlinkConnection('tcp:127.0.0.1:5760', threaded=True, PX4=False)
drone = Drone(conn)

time.sleep(2)
drone.start()
drone.take_control()
drone.arm()
drone.set_home_as_current_position()
drone.takeoff(40)

